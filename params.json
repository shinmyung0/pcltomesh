{
  "name": "Point Cloud to Mesh",
  "tagline": "Point cloud data to mesh with possible down sampling.",
  "body": "# Project Proposal\r\n\r\n### 1. Team\r\nShin Yoon\r\n\r\n### 2. Background\r\nThe idea is simple. A point cloud is just a bunch of unordered vertices. What we want to do is to group these vertices into triangles to form a mesh. Why is this useful? This is extremely useful in fields like 3D reconstruction, where you have large amounts of point cloud data from RGBD cameras or lidar, and you want to recreate a mesh representing the object that you scanned. This is how meshes of objects scanned for 3D printers are generated. This is also useful in SLAM(Simultaneous Localization and Mapping) for robots trying to create a 3D reconstruction of their surroundings. \r\n\r\nThis is the reason why this project is interesting for me personally. I'm currently involved in research regarding super-resolution SLAM on UAVs. The idea is to use localized RGBD point cloud data and then generate a mesh of the surroundings. Then using a high resolution camera map textures to this mesh of a view that the UAV is \"seeing.\" The first part of this research project is something that I've been interested in, so I wanted to try to implement the basics within the scope of this project. \r\n\r\nTo start off I plan to try to implement [this paper](http://www.research.ibm.com/vistechnology/pdf/bpa_tvcg.pdf) using the mesh data provided [here](http://graphics.stanford.edu/data/3Dscanrep/). Afterwards, once I get it working on standard data sets, I want to try to implement a form of down sampling as well to try and simplify the point cloud before running a meshing algorithm on it. This part is important because in our own research, the point clouds that are generated are extremely dense, but a lot of the data can be reduced and still generate a nice mesh. But the main goal for this project is to actual implement the mesh generation algorithm.\r\n\r\n### 3. Resources\r\nLanguage + Platform : C++/ OpenGL \r\nLibraries : Point Cloud Library (File parsing, Data manipulation), Eigen (Vector, Matrix), CS184 HW2 MeshEdit\r\n\r\nI am planning on using our hw2 code base to use as the starting point. I think the visualizer was useful and using that as the starting point will help me debug and implement faster. \r\n\r\n### 4. Goals and Deliverables\r\n\r\nMy main deliverable will be to demo the mesh generation algorithm using vertices from the [Stanford 3D Scanning Repository](stanford_3d). I plan to implement the [Ball Pivot Algorithm](bpa) to show how vertices can be grouped together to form a mesh.\r\n\r\n![Point Cloud to Mesh](http://cs184.eecs.berkeley.edu/cs184_sp16_content/article_images/21_2.jpg)\r\n\r\nIn terms of aspirational goals, I want to also implement the [Poisson Surface Reconstruction Algorithm](poisson) and do a comparison of the two methods on a model. Then if that goes well, I want to try to run my algorithm on actual point cloud data from the SLAM program that we are running in my research project. This would hopefully generate a rough mesh of whatever the RGBD camera is seeing localized. This would involve writing a [ROS Publisher/Subscriber] (ros_pubsub) wrapper around my mesh generator, and streaming the data from the SLAM program and back out into [Rviz](rviz). \r\n\r\n### 5. Intended Schedule\r\n- April 24th - Finish the Ball Pivot Algorithm + Downsampling + augment HW2 code base to incorporate it\r\n- May 1st - try to implement Poisson Surface Reconstruction and compare with Ball Pivot Algorithm\r\n- May 3rd - Possibly look into ROS integration and writing a publisher/subscriber, prepare demo.\r\n\r\n# Final Report (As of May 4th)\r\n\r\n### 1. Summary\r\n\r\nThis is the final report write up for CS184 Spring 2016. I finished my main goal of implementing the Ball Pivoting Algorithm to generate a mesh from point cloud data, although I did not quite reach my aspirational goals. In the process of implementing this project, I learned a lot about the trade offs involved in generating a mesh from point cloud data. I plan to continue to develop on this project even after this semester, and hopefully reach my aspirational goals some time in the future, mainly testing out Poisson Surface Reconstruction as well as integration with UAV point cloud data. There were some divergences from my original proposal, mainly involving the data sets being used. I originally planned to use the Stanford 3D Scanning Repository, but when I opened the .ply files, I found that there were already polygon relationships defined inside. I wanted to test on more realistic point cloud data, so instead I found [a repository of .pcd files](pcd_files) containing only vertices. This format was specifically designed to contain point cloud data, and also the format was well supported within the Point Cloud Library(PCL).\r\n\r\n### 2. Abstract\r\n\r\nThe main focus of this project was to implement the Ball Pivot algorithm on point cloud data. The overall algorithm followed the previously mentioned paper closely. The basic idea of the algorithm is simple : there is an \"advancing front\" of active edges from which a ball of radius, p, is rotated around until the ball \"hits\" a vertex in which case the vertex is joined together with the current mesh. Newly created edges are joined to the mesh, and older edges are removed from the front. To start the algorithm, there is a seed triangle the defines the initial front from which the ball starts to pivot from.\r\n\r\n![Advancing Front](http://gdurl.com/kBDc)\r\n\r\n*Advancing Front*\r\n\r\n### 3.1 Parsing and Structuring the Point Cloud Data\r\n\r\nTo parse and structure the data I used PCL. PCL offers a PCDReader to easily parse .pcd files into their PointCloud data structure. From this I used PCL's KDTree to organize the parsed vertices. I did this because the Ball Pivot Algorithm(BPA) involves pivoting a ball in space and determining whether certain vertices are hit, thus requiring a lot of spatial queries. A KDTree is very efficient in doing nearest neighbor spatial queries, also PCL had excellent support for spatially partitioning points as well as searching inside a KDTree.\r\n\r\n\r\n### 3.2 Calculating the normal\r\n\r\nCalculating normal vectors for unstructured point cloud data comes down to estimating the normal by fitting a least-squares plane around k-neighboring points. For determining the sign of the normal, we can assume to orient everything towards the viewpoint. PCL already provides methods for doing this using outlined [here](normals). \r\n\r\n![kneighbors](http://gdurl.com/koAO)\r\n\r\n\r\n### 3.3 Selecting a Seed Triangle\r\n\r\nAn initial front of edges is created by selecting a seed triangle. I selected a seed triangle by getting any random point not yet used by the algorithm, then searching with the nearest neighboring points until I found 2 other points that formed a triangle that satisfied two conditions: the triangle is consistent with the surface normals and a p-radius ball contains all three points without having any other points inside. The initial front is the edges of this triangle.\r\n\r\n![seeds](http://gdurl.com/2dPf)\r\n \r\n\r\n### 3.4 Ball Pivoting\r\n\r\nAnytime we pivot the ball, we need to look within a radius p for points the the ball would hit as it pivoted long an edge. We need to query points within a 2*p distance from the points that we are querying from. Starting from an active edge, we first calculate the midpoint of the edge,  For every point within this neighborhood we compute the center of a sphere touch v0, v1 (points from the original edge), and vn(new point we are testing), if such a ball exists. The center of this sphere, cx, intersects with the circular path that our ball draws, in two points. We choose the first of these points. For all points taken into consideration, we must also consider whether or not the generated face's normal is consistent with the face that the pivot edge belongs to.\r\n\r\n![3D Representation](http://patentimages.storage.googleapis.com/US6968299B1/US06968299-20051122-D00000.png)\r\n\r\n### 4. Results and Technical Difficulties\r\n\r\nMesh generation of a single side of the Stanford Bunny. Tried with various radius sizes, r=0.01, 0.02 displayed here. You can see as the radius of the ball increases more points are missed and you get a lower resolution mesh. The mesh generation is far from perfect, but the original point cloud itself was a little sparse.\r\n\r\n\r\n![original_mesh](http://gdurl.com/Hmrc)\r\n\r\n*Original Mesh*\r\n\r\n![r001](http://gdurl.com/64MI)\r\n\r\n*Radius 0.01 Generated Mesh*\r\n\r\n![r002](http://gdurl.com/bdeQ)\r\n\r\n\r\nI tried it with a bigger point cloud of a few thousand points. This point cloud has around ~3500 points. The mesh was generated with a radius of 5.0. You can see that the tail area of the point cloud cat has points spaced much farther apart, and this causes disconnected parts of the mesh. The tail is still partially rendered because the algorithm keeps generating the mesh from new seed triangles until they can no longer be generated. \r\n\r\n![cat_cloud](http://gdurl.com/J0dY)\r\n\r\n*Original Point Cloud ~3500 points*\r\n\r\n![cat_mesh](http://gdurl.com/rlmk)\r\n\r\n*Radius 5.0 Generated Mesh*\r\n\r\n\r\nThe hardest thing about this algorithm was deciding on the correct radius value for my pivoting ball. During simple testing I just looked at the vertex values and set some random scale for my ball radius, but some meshes have varied areas of dense point clouds versus sparse point clouds. The tail area of the cat mesh shows what happens when certain areas of the mesh have sparser clouds than others. The main body was generated well, but the tail had disconnected parts of the meshes. I was playing around with ways to dynamically set the radius based off of sampled subsets of the points as well as increasing the pivot ball's radius at an active edge and trying again when it couldn't find a point. But I couldn't get it to work successfully in time. This is one of the things that I plan to improve upon in the future.\r\n\r\nAnother thing I found difficult was that despite using PCL's normal estimator, a lot of my surface normals were not being approximated correctly. I'm not sure if this is because there is a bug in my code, or if I did not set a high enough k neighbor value for plane fitting, but I found that because of incorrect normals some mesh surfaces, especially around sharp curvatures such as feet, tails, or other circular meshes. You can see this effect in the cat mesh as well. Some parts of the surface have normals inconsistent with the rest of the mesh that cause the feet and face part of the cat to have mesh generation be cut off. This is also something I want to improve and fix in the future.\r\n\r\n\r\n### Future Todo List\r\n\r\n- Fix bugs in normal estimation\r\n- Dynamic ball radius\r\n- Implement some of the out of core algorithms talked about in the original paper to handle larger meshes\r\n- Try incorporating streaming point cloud data from a UAV using ROS\r\n\r\n### References\r\n\r\nFor this project, I heavily referenced the [PCL documentation](pcldocs). I also read more about the algorithm and used some images from [this](bpapres) presentation I found on the web.\r\n\r\n\r\n[bpapres]: http://www.cs.hunter.cuny.edu/~ioannis/24_BPA_SLIDES.pdf\r\n[pcldocs]: http://pointclouds.org/documentation/\r\n[normals]: http://pointclouds.org/documentation/tutorials/normal_estimation.php#normal-estimation\r\n[rviz]: http://wiki.ros.org/rviz\r\n[ros_pubsub]: http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber\r\n[stanford_3d]: http://graphics.stanford.edu/data/3Dscanrep/\r\n[bpa]: http://www.research.ibm.com/vistechnology/pdf/bpa_tvcg.pdf\r\n[poisson]: http://research.microsoft.com/en-us/um/people/hoppe/poissonrecon.pdf\r\n[pcd_files]: https://github.com/PointCloudLibrary/data\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}