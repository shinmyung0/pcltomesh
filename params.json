{
  "name": "Point Cloud to Mesh",
  "tagline": "Point cloud data to mesh with possible down sampling.",
  "body": "# Project Proposal\r\n\r\n### 1. Team\r\nShin Yoon\r\n\r\n### 2. Background\r\nThe idea is simple. A point cloud is just a bunch of unordered vertices. What we want to do is to group these vertices into triangles to form a mesh. Why is this useful? This is extremely useful in fields like 3D reconstruction, where you have large amounts of point cloud data from RGBD cameras or lidar, and you want to recreate a mesh representing the object that you scanned. This is how meshes of objects scanned for 3D printers are generated. This is also useful in SLAM(Simultaneous Localization and Mapping) for robots trying to create a 3D reconstruction of their surroundings. \r\n\r\nThis is the reason why this project is interesting for me personally. I'm currently involved in research regarding super-resolution SLAM on UAVs. The idea is to use localized RGBD point cloud data and then generate a mesh of the surroundings. Then using a high resolution camera map textures to this mesh of a view that the UAV is \"seeing.\" The first part of this research project is something that I've been interested in, so I wanted to try to implement the basics within the scope of this project. \r\n\r\nTo start off I plan to try to implement [this paper](http://www.research.ibm.com/vistechnology/pdf/bpa_tvcg.pdf) using the mesh data provided [here](http://graphics.stanford.edu/data/3Dscanrep/). Afterwards, once I get it working on standard data sets, I want to try to implement a form of down sampling as well to try and simplify the point cloud before running a meshing algorithm on it. This part is important because in our own research, the point clouds that are generated are extremely dense, but a lot of the data can be reduced and still generate a nice mesh. But the main goal for this project is to actual implement the mesh generation algorithm.\r\n\r\n### 3. Resources\r\nLanguage + Platform : C++/ OpenGL \r\nLibraries : Point Cloud Library (File parsing, Data manipulation), Eigen (Vector, Matrix), CS184 HW2 MeshEdit\r\n\r\nI am planning on using our hw2 code base to use as the starting point. I think the visualizer was useful and using that as the starting point will help me debug and implement faster. \r\n\r\n### 4. Goals and Deliverables\r\n\r\nMy main deliverable will be to demo the mesh generation algorithm using vertices from the [Stanford 3D Scanning Repository](stanford_3d). I plan to implement the [Ball Pivot Algorithm](bpa) to show how vertices can be grouped together to form a mesh.\r\n\r\n![Point Cloud to Mesh](http://cs184.eecs.berkeley.edu/cs184_sp16_content/article_images/21_2.jpg)\r\n\r\nIn terms of aspirational goals, I want to also implement the [Poisson Surface Reconstruction Algorithm](poisson) and do a comparison of the two methods on a model. Then if that goes well, I want to try to run my algorithm on actual point cloud data from the SLAM program that we are running in my research project. This would hopefully generate a rough mesh of whatever the RGBD camera is seeing localized. This would involve writing a [ROS Publisher/Subscriber] (ros_pubsub) wrapper around my mesh generator, and streaming the data from the SLAM program and back out into [Rviz](rviz). \r\n\r\n### 5. Intended Schedule\r\n- April 24th - Finish the Ball Pivot Algorithm + Downsampling + augment HW2 code base to incorporate it\r\n- May 1st - try to implement Poisson Surface Reconstruction and compare with Ball Pivot Algorithm\r\n- May 3rd - Possibly look into ROS integration and writing a publisher/subscriber, prepare demo.\r\n\r\n# Final Report (As of May 4th)\r\n\r\n### 1. Summary\r\n\r\nThis is the final report write up for CS184 Spring 2016. I finished my main goal of implementing the Ball Pivoting Algorithm to generate a mesh from point cloud data, although I did not quite reach my aspirational goals. In the process of implementing this project, I learned a lot about the trade offs involved in generating a mesh from point cloud data. I plan to continue to develop on this project even after this semester, and hopefully reach my aspirational goals some time in the future, mainly testing out Poisson Surface Reconstruction as well as integration with UAV point cloud data. There were some divergences from my original proposal, mainly involving the data sets being used. I originally planned to use the Stanford 3D Scanning Repository, but when I opened the .ply files, I found that there were already polygon relationships defined inside. I wanted to test on more realistic point cloud data, so instead I found [this](pcd_files) which were .pcd containing only vertices. This format was specifically designed to contain point cloud data, and also the format was well supported within the Point Cloud Library(PCL).\r\n\r\n### 2. Abstract\r\n\r\nThe main focus of this project was to implement the Ball Pivot algorithm on point cloud data. The overall algorithm followed the previously mentioned paper closely. The basic idea of the algorithm is simple : there is an \"advancing front\" of active edges from which a ball of radius, p, is rotated around until the ball \"hits\" a vertex in which case the vertex is joined together with the current mesh. Newly created edges are joined to the mesh, and older edges are removed from the front. To start the algorithm, there is a seed triangle the defines the initial front from which the ball starts to pivot from.\r\n\r\n![Advancing Front](https://drive.google.com/file/d/0BzGKQAoknGiIajhKYzR1VV8xWXM/view?usp=sharing)\r\n*Advancing Front*\r\n\r\n### 3.1 Parsing and Structuring the Point Cloud Data\r\n\r\nTo parse and structure the data I used PCL. PCL offers a PCDReader to easily parse .pcd files into their PointCloud data structure. From this I used PCL's KDTree to organize the parsed vertices. I did this because the Ball Pivot Algorithm(BPA) involves pivoting a ball in space and determining whether certain vertices are hit, thus requiring a lot of spatial queries. A KDTree is very efficient in doing nearest neighbor spatial queries, also PCL had excellent support for spatially partitioning points as well as searching inside a KDTree. \r\n\r\n\r\n\r\n### 3.2 Selecting a Seed Triangle\r\n\r\nAn initial front of edges is created by selecting a seed triangle. I selected a seed triangle by getting any random point not yet used by the algorithm, then searching with the nearest neighboring points until I found 2 other points that formed a triangle that satisfied two conditions: the triangle is consistent with the surface normals and a p-radius ball contains all three points without having any other points inside. The initial front would be the edges of this triangle. \r\n\r\n### 3.3 Ball Pivoting\r\n\r\nAnytime we pivot the ball, we need to look within a radius p for points the the ball would hit as it pivoted long an edge. Below is a diagram depicting the required dimensions to check for collision of the ball with a vertex. We need to query points within a 2*p distance from the points that we are querying from. For each potential point we need to check that \r\n\r\n\r\n![Ball pivot dimension](http://gdurl.com/u2lL)\r\n![3D Representation](http://patentimages.storage.googleapis.com/US6968299B1/US06968299-20051122-D00000.png)\r\n\r\n\r\n[rviz] : http://wiki.ros.org/rviz\r\n[ros_pubsub] : http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber\r\n[stanford_3d] : http://graphics.stanford.edu/data/3Dscanrep/\r\n[bpa] : http://www.research.ibm.com/vistechnology/pdf/bpa_tvcg.pdf\r\n[poisson] : http://research.microsoft.com/en-us/um/people/hoppe/poissonrecon.pdf\r\n[pcd_files] : https://github.com/PointCloudLibrary/data\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}